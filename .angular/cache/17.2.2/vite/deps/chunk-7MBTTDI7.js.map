{
  "version": 3,
  "sources": ["../../../../../node_modules/@ng-idle/core/fesm2022/ng-idle-core.mjs"],
  "sourcesContent": ["import * as i0 from '@angular/core';\nimport { Injectable, EventEmitter, PLATFORM_ID, Optional, Inject, NgModule } from '@angular/core';\nimport { isPlatformServer } from '@angular/common';\nimport { Subscription, fromEvent, merge } from 'rxjs';\nimport { filter, throttleTime } from 'rxjs/operators';\n\n/*\n * A class for managing an interrupt from an interrupt source.\n */\nclass Interrupt {\n  constructor(source, options) {\n    this.source = source;\n    if (source.initialize) {\n      source.initialize(options);\n    }\n  }\n  /*\n   * Subscribes to the interrupt using the specified function.\n   * @param fn - The subscription function.\n   */\n  subscribe(fn) {\n    this.sub = this.source.onInterrupt.subscribe(fn);\n  }\n  /*\n   * Unsubscribes the interrupt.\n   */\n  unsubscribe() {\n    this.sub.unsubscribe();\n    this.sub = null;\n  }\n  /*\n   * Keeps the subscription but resumes interrupt events.\n   */\n  resume() {\n    this.source.attach();\n  }\n  /*\n   * Keeps the subscription but pauses interrupt events.\n   */\n  pause() {\n    this.source.detach();\n  }\n}\n\n/*\n * Represents a base class for types that provide expiry detection for the Idle service.\n */\nclass IdleExpiry {\n  constructor() {\n    this.idValue = new Date();\n    this.idlingValue = false;\n  }\n  /*\n   * Gets or sets a unique ID for the window\n   * @param id - The id.\n   * @return The current id.\n   */\n  id(value) {\n    if (value !== void 0) {\n      if (!value) {\n        throw new Error('A value must be specified for the ID.');\n      }\n      this.idValue = value;\n    }\n    return this.idValue;\n  }\n  /*\n   * Gets or sets the idling value.\n   * @param value - The value to set.\n   * @return The idling value.\n   */\n  idling(value) {\n    if (value !== void 0) {\n      this.idlingValue = value;\n    }\n    return this.idlingValue;\n  }\n  /*\n   * Returns the current Date.\n   * @return The current Date.\n   */\n  now() {\n    /* istanbul ignore next */\n    return new Date();\n  }\n  /*\n   * Returns whether or not it is expired.\n   * @return True if expired; otherwise, false.\n   */\n  isExpired() {\n    const expiry = this.last();\n    return expiry != null && expiry <= this.now();\n  }\n}\n\n/*\n * Represents an alternative storage for browser that doesn't support localstorage. (i.e. Safari in\n * private mode)\n * @implements Storage\n */\nclass AlternativeStorage {\n  constructor() {\n    this.storageMap = {};\n  }\n  /*\n   * Returns an integer representing the number of data items stored in the storageMap object.\n   */\n  get length() {\n    return Object.keys(this.storageMap).length;\n  }\n  /*\n   * Remove all keys out of the storage.\n   */\n  clear() {\n    this.storageMap = {};\n  }\n  /*\n   * Return the key's value\n   *\n   * @param key - name of the key to retrieve the value of.\n   * @return The key's value\n   */\n  getItem(key) {\n    if (typeof this.storageMap[key] !== 'undefined') {\n      return this.storageMap[key];\n    }\n    return null;\n  }\n  /*\n   * Return the nth key in the storage\n   *\n   * @param index - the number of the key you want to get the name of.\n   * @return The name of the key.\n   */\n  key(index) {\n    return Object.keys(this.storageMap)[index] || null;\n  }\n  /*\n   * Remove a key from the storage.\n   *\n   * @param key - the name of the key you want to remove.\n   */\n  removeItem(key) {\n    this.storageMap[key] = undefined;\n  }\n  /*\n   * Add a key to the storage, or update a key's value if it already exists.\n   *\n   * @param key - the name of the key.\n   * @param value - the value you want to give to the key.\n   */\n  setItem(key, value) {\n    this.storageMap[key] = value;\n  }\n}\n\n/*\n * Represents a localStorage store.\n */\nclass LocalStorage {\n  constructor() {\n    this.storage = this.getStorage();\n  }\n  /*\n   * Safari, in Private Browsing Mode, looks like it supports localStorage but all calls to setItem\n   * throw QuotaExceededError. We're going to detect this and just silently drop any calls to\n   * setItem\n   * to avoid the entire page breaking, without having to do a check at each usage of Storage.\n   */\n  getStorage() {\n    try {\n      const storage = localStorage;\n      storage.setItem('ng2IdleStorage', '');\n      storage.removeItem('ng2IdleStorage');\n      return storage;\n    } catch (err) {\n      return new AlternativeStorage();\n    }\n  }\n  /*\n   * Gets an item in the storage.\n   *\n   * @param value - The value to get.\n   * @return The current value.\n   */\n  getItem(key) {\n    return this.storage.getItem('ng2Idle.' + key);\n  }\n  /*\n   * Removes an item in the storage.\n   *\n   * @param value - The value to remove.\n   */\n  removeItem(key) {\n    this.storage.removeItem('ng2Idle.' + key);\n  }\n  /*\n   * Sets an item in the storage.\n   *\n   * @param key - The key to set the value.\n   * @param value - The value to set to the key.\n   */\n  setItem(key, data) {\n    this.storage.setItem('ng2Idle.' + key, data);\n  }\n  /*\n   * Represents the storage, commonly use for testing purposes.\n   *\n   * @param key - The key to set the value.\n   * @param value - The value to set to the key.\n   */\n  _wrapped() {\n    return this.storage;\n  }\n  static {\n    this.ɵfac = function LocalStorage_Factory(t) {\n      return new (t || LocalStorage)();\n    };\n  }\n  static {\n    this.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: LocalStorage,\n      factory: LocalStorage.ɵfac\n    });\n  }\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(LocalStorage, [{\n    type: Injectable\n  }], function () {\n    return [];\n  }, null);\n})();\n\n/*\n * Represents a localStorage store of expiry values.\n * @extends IdleExpiry\n */\nclass LocalStorageExpiry extends IdleExpiry {\n  constructor(localStorage) {\n    super();\n    this.localStorage = localStorage;\n    this.idleName = 'main';\n  }\n  /*\n   * Gets or sets the last expiry date in localStorage.\n   * If localStorage doesn't work correctly (i.e. Safari in private mode), we store the expiry value in memory.\n   * @param value - The expiry value to set; omit to only return the value.\n   * @return The current expiry value.\n   */\n  last(value) {\n    if (value !== void 0) {\n      this.setExpiry(value);\n    }\n    return this.getExpiry();\n  }\n  idling(value) {\n    if (value !== void 0) {\n      this.setIdling(value);\n    }\n    return this.getIdling();\n  }\n  /*\n   * Gets the idle name.\n   * @return The name of the idle.\n   */\n  getIdleName() {\n    return this.idleName;\n  }\n  /*\n   * Sets the idle name.\n   * @param The name of the idle.\n   */\n  setIdleName(key) {\n    if (key) {\n      this.idleName = key;\n    }\n  }\n  getExpiry() {\n    const expiry = this.localStorage.getItem(this.idleName + '.expiry');\n    if (expiry) {\n      return new Date(parseInt(expiry, 10));\n    } else {\n      return null;\n    }\n  }\n  setExpiry(value) {\n    if (value) {\n      this.localStorage.setItem(this.idleName + '.expiry', value.getTime().toString());\n    } else {\n      this.localStorage.removeItem(this.idleName + '.expiry');\n    }\n  }\n  getIdling() {\n    const idling = this.localStorage.getItem(this.idleName + '.idling');\n    if (idling) {\n      return idling === 'true';\n    } else {\n      return false;\n    }\n  }\n  setIdling(value) {\n    if (value) {\n      this.localStorage.setItem(this.idleName + '.idling', value.toString());\n    } else {\n      this.localStorage.setItem(this.idleName + '.idling', 'false');\n    }\n  }\n  static {\n    this.ɵfac = function LocalStorageExpiry_Factory(t) {\n      return new (t || LocalStorageExpiry)(i0.ɵɵinject(LocalStorage));\n    };\n  }\n  static {\n    this.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: LocalStorageExpiry,\n      factory: LocalStorageExpiry.ɵfac\n    });\n  }\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(LocalStorageExpiry, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: LocalStorage\n    }];\n  }, null);\n})();\nclass KeepaliveSvc {}\n\n/*\n * Indicates the desired auto resume behavior.\n */\nvar AutoResume;\n(function (AutoResume) {\n  /*\n   * Auto resume functionality will be disabled.\n   */\n  AutoResume[AutoResume[\"disabled\"] = 0] = \"disabled\";\n  /*\n   * Can resume automatically even if they are idle.\n   */\n  AutoResume[AutoResume[\"idle\"] = 1] = \"idle\";\n  /*\n   * Can only resume automatically if they are not yet idle.\n   */\n  AutoResume[AutoResume[\"notIdle\"] = 2] = \"notIdle\";\n})(AutoResume || (AutoResume = {}));\n/**\n * A service for detecting and responding to user idleness.\n */\nclass Idle {\n  constructor(expiry, zone, keepaliveSvc, platformId) {\n    this.expiry = expiry;\n    this.zone = zone;\n    this.platformId = platformId;\n    this.idle = 20 * 60; // in seconds\n    this.timeoutVal = 30; // in seconds\n    this.autoResume = AutoResume.idle;\n    this.interrupts = new Array();\n    this.running = false;\n    this.keepaliveEnabled = false;\n    this.onIdleStart = new EventEmitter();\n    this.onIdleEnd = new EventEmitter();\n    this.onTimeoutWarning = new EventEmitter();\n    this.onTimeout = new EventEmitter();\n    this.onInterrupt = new EventEmitter();\n    if (keepaliveSvc) {\n      this.keepaliveSvc = keepaliveSvc;\n      this.keepaliveEnabled = true;\n    }\n    this.setIdling(false);\n  }\n  /*\n   * Sets the idle name for localStorage.\n   * Important to set if multiple instances of Idle with LocalStorageExpiry\n   * @param The name of the idle.\n   */\n  setIdleName(key) {\n    if (this.expiry instanceof LocalStorageExpiry) {\n      this.expiry.setIdleName(key);\n    } else {\n      throw new Error('Cannot set expiry key name because no LocalStorageExpiry has been provided.');\n    }\n  }\n  /*\n   * Returns whether or not keepalive integration is enabled.\n   * @return True if integration is enabled; otherwise, false.\n   */\n  getKeepaliveEnabled() {\n    return this.keepaliveEnabled;\n  }\n  /*\n   * Sets and returns whether or not keepalive integration is enabled.\n   * @param True if the integration is enabled; otherwise, false.\n   * @return The current value.\n   */\n  setKeepaliveEnabled(value) {\n    if (!this.keepaliveSvc) {\n      throw new Error('Cannot enable keepalive integration because no KeepaliveSvc has been provided.');\n    }\n    return this.keepaliveEnabled = value;\n  }\n  /*\n   * Returns the current timeout value.\n   * @return The timeout value in seconds.\n   */\n  getTimeout() {\n    return this.timeoutVal;\n  }\n  /*\n   * Sets the timeout value.\n   * @param seconds - The timeout value in seconds. 0 or false to disable timeout feature.\n   * @return The current value. If disabled, the value will be 0.\n   */\n  setTimeout(seconds) {\n    if (seconds === false) {\n      this.timeoutVal = 0;\n    } else if (typeof seconds === 'number' && seconds >= 0) {\n      this.timeoutVal = seconds;\n    } else {\n      throw new Error(\"'seconds' can only be 'false' or a positive number.\");\n    }\n    return this.timeoutVal;\n  }\n  /*\n   * Returns the current idle value.\n   * @return The idle value in seconds.\n   */\n  getIdle() {\n    return this.idle;\n  }\n  /*\n   * Sets the idle value.\n   * @param seconds - The idle value in seconds.\n   * @return The idle value in seconds.\n   */\n  setIdle(seconds) {\n    if (seconds <= 0) {\n      throw new Error(\"'seconds' must be greater zero\");\n    }\n    return this.idle = seconds;\n  }\n  /*\n   * Returns the current autoresume value.\n   * @return The current value.\n   */\n  getAutoResume() {\n    return this.autoResume;\n  }\n  setAutoResume(value) {\n    return this.autoResume = value;\n  }\n  /*\n   * Sets interrupts from the specified sources.\n   * @param sources - Interrupt sources.\n   * @return The resulting interrupts.\n   */\n  setInterrupts(sources) {\n    this.clearInterrupts();\n    const self = this;\n    for (const source of sources) {\n      const options = {\n        platformId: this.platformId\n      };\n      const sub = new Interrupt(source, options);\n      sub.subscribe(args => {\n        self.interrupt(args.force, args.innerArgs);\n      });\n      this.interrupts.push(sub);\n    }\n    return this.interrupts;\n  }\n  /*\n   * Returns the current interrupts.\n   * @return The current interrupts.\n   */\n  getInterrupts() {\n    return this.interrupts;\n  }\n  /*\n   * Pauses, unsubscribes, and clears the current interrupt subscriptions.\n   */\n  clearInterrupts() {\n    for (const sub of this.interrupts) {\n      sub.pause();\n      sub.unsubscribe();\n    }\n    this.interrupts.length = 0;\n  }\n  /*\n   * Returns whether or not the service is running i.e. watching for idleness.\n   * @return True if service is watching; otherwise, false.\n   */\n  isRunning() {\n    return this.running;\n  }\n  /*\n   * Returns whether or not the user is considered idle.\n   * @return True if the user is in the idle state; otherwise, false.\n   */\n  isIdling() {\n    return this.idling;\n  }\n  /*\n   * Starts watching for inactivity.\n   */\n  watch(skipExpiry) {\n    this.safeClearInterval('idleHandle');\n    this.safeClearInterval('timeoutHandle');\n    const timeout = !this.timeoutVal ? 0 : this.timeoutVal;\n    if (!skipExpiry) {\n      const value = new Date(this.expiry.now().getTime() + (this.idle + timeout) * 1000);\n      this.expiry.last(value);\n    }\n    if (this.idling) {\n      this.toggleState();\n    }\n    if (!this.running) {\n      this.startKeepalive();\n      this.toggleInterrupts(true);\n    }\n    this.running = true;\n    const watchFn = () => {\n      this.zone.run(() => {\n        const diff = this.getExpiryDiff(timeout);\n        if (diff > 0) {\n          this.safeClearInterval('idleHandle');\n          this.setIdleIntervalOutsideOfZone(watchFn, 1000);\n        } else {\n          this.toggleState();\n        }\n      });\n    };\n    this.setIdleIntervalOutsideOfZone(watchFn, 1000);\n  }\n  /*\n   * Allows protractor tests to call waitForAngular without hanging\n   */\n  setIdleIntervalOutsideOfZone(watchFn, frequency) {\n    this.zone.runOutsideAngular(() => {\n      this.idleHandle = setInterval(watchFn, frequency);\n    });\n  }\n  /*\n   * Stops watching for inactivity.\n   */\n  stop() {\n    this.stopKeepalive();\n    this.toggleInterrupts(false);\n    this.safeClearInterval('idleHandle');\n    this.safeClearInterval('timeoutHandle');\n    this.setIdling(false);\n    this.running = false;\n    this.expiry.last(null);\n  }\n  /*\n   * Forces a timeout event and state.\n   */\n  timeout() {\n    this.stopKeepalive();\n    this.toggleInterrupts(false);\n    this.safeClearInterval('idleHandle');\n    this.safeClearInterval('timeoutHandle');\n    this.setIdling(true);\n    this.running = false;\n    this.countdown = 0;\n    this.onTimeout.emit(null);\n  }\n  /*\n   * Signals that user activity has occurred.\n   * @param force - Forces watch to be called, unless they are timed out.\n   * @param eventArgs - Optional source event arguments.\n   */\n  interrupt(force, eventArgs) {\n    if (!this.running) {\n      return;\n    }\n    if (this.timeoutVal && this.expiry.isExpired()) {\n      this.timeout();\n      return;\n    }\n    this.onInterrupt.emit(eventArgs);\n    if (force === true || this.autoResume === AutoResume.idle || this.autoResume === AutoResume.notIdle && !this.expiry.idling()) {\n      this.watch(force);\n    }\n  }\n  setIdling(value) {\n    this.idling = value;\n    this.expiry.idling(value);\n  }\n  toggleState() {\n    this.setIdling(!this.idling);\n    if (this.idling) {\n      this.onIdleStart.emit(null);\n      this.stopKeepalive();\n      if (this.timeoutVal > 0) {\n        this.countdown = this.timeoutVal;\n        this.doCountdown();\n        this.setTimeoutIntervalOutsideZone(() => {\n          this.doCountdownInZone();\n        }, 1000);\n      }\n    } else {\n      this.toggleInterrupts(true);\n      this.onIdleEnd.emit(null);\n      this.startKeepalive();\n    }\n    this.safeClearInterval('idleHandle');\n  }\n  setTimeoutIntervalOutsideZone(intervalFn, frequency) {\n    this.zone.runOutsideAngular(() => {\n      this.timeoutHandle = setInterval(() => {\n        intervalFn();\n      }, frequency);\n    });\n  }\n  toggleInterrupts(resume) {\n    for (const interrupt of this.interrupts) {\n      if (resume) {\n        interrupt.resume();\n      } else {\n        interrupt.pause();\n      }\n    }\n  }\n  getExpiryDiff(timeout) {\n    const now = this.expiry.now();\n    const last = this.expiry.last() || now;\n    return last.getTime() - now.getTime() - timeout * 1000;\n  }\n  doCountdownInZone() {\n    this.zone.run(() => {\n      this.doCountdown();\n    });\n  }\n  doCountdown() {\n    const diff = this.getExpiryDiff(this.timeoutVal);\n    if (diff > 0) {\n      this.safeClearInterval('timeoutHandle');\n      this.interrupt(true);\n      return;\n    }\n    if (!this.idling) {\n      return;\n    }\n    if (this.countdown <= 0) {\n      this.timeout();\n      return;\n    }\n    this.onTimeoutWarning.emit(this.countdown);\n    const countdownMs = (this.timeoutVal - 1) * 1000 + diff;\n    this.countdown = Math.round(countdownMs / 1000);\n  }\n  safeClearInterval(handleName) {\n    const handle = this[handleName];\n    if (handle !== null && typeof handle !== 'undefined') {\n      clearInterval(this[handleName]);\n      this[handleName] = null;\n    }\n  }\n  startKeepalive() {\n    if (!this.keepaliveSvc || !this.keepaliveEnabled) {\n      return;\n    }\n    if (this.running) {\n      this.keepaliveSvc.ping();\n    }\n    this.keepaliveSvc.start();\n  }\n  stopKeepalive() {\n    if (!this.keepaliveSvc || !this.keepaliveEnabled) {\n      return;\n    }\n    this.keepaliveSvc.stop();\n  }\n  /*\n   * Called by Angular when destroying the instance.\n   */\n  ngOnDestroy() {\n    this.stop();\n    this.clearInterrupts();\n  }\n  static {\n    this.ɵfac = function Idle_Factory(t) {\n      return new (t || Idle)(i0.ɵɵinject(IdleExpiry), i0.ɵɵinject(i0.NgZone), i0.ɵɵinject(KeepaliveSvc, 8), i0.ɵɵinject(PLATFORM_ID, 8));\n    };\n  }\n  static {\n    this.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: Idle,\n      factory: Idle.ɵfac\n    });\n  }\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(Idle, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: IdleExpiry\n    }, {\n      type: i0.NgZone\n    }, {\n      type: KeepaliveSvc,\n      decorators: [{\n        type: Optional\n      }]\n    }, {\n      type: Object,\n      decorators: [{\n        type: Optional\n      }, {\n        type: Inject,\n        args: [PLATFORM_ID]\n      }]\n    }];\n  }, null);\n})();\n\n/*\n * A class for expressing arguments to interrupt events.\n */\nclass InterruptArgs {\n  constructor(source, innerArgs, force = false) {\n    this.source = source;\n    this.innerArgs = innerArgs;\n    this.force = force;\n  }\n}\n\n/*\n * A base for classes that act as a source for interrupts.\n */\nclass InterruptSource {\n  constructor(attachFn, detachFn) {\n    this.attachFn = attachFn;\n    this.detachFn = detachFn;\n    this.isAttached = false;\n    this.onInterrupt = new EventEmitter();\n  }\n  /*\n   * Attaches to the specified events on the specified source.\n   */\n  attach() {\n    // If the current zone is the 'angular' zone (a.k.a. NgZone) then re-enter this method in its parent zone\n    // The parent zone is usually the '<root>' zone but it can also be 'long-stack-trace-zone' in debug mode\n    // In tests, the current zone is typically a 'ProxyZone' created by async/fakeAsync (from @angular/core/testing)\n    if (Zone.current.get('isAngularZone') === true) {\n      Zone.current.parent.run(() => this.attach());\n      return;\n    }\n    if (!this.isAttached && this.attachFn) {\n      this.attachFn(this);\n    }\n    this.isAttached = true;\n  }\n  /*\n   * Detaches from the specified events on the specified source.\n   */\n  detach() {\n    if (this.isAttached && this.detachFn) {\n      this.detachFn(this);\n    }\n    this.isAttached = false;\n  }\n}\nconst defaultThrottleDelay = 500;\n/*\n * An interrupt source on an EventTarget object, such as a Window or HTMLElement.\n */\nclass EventTargetInterruptSource extends InterruptSource {\n  constructor(target, events, opts) {\n    super(null, null);\n    this.target = target;\n    this.events = events;\n    this.opts = opts;\n    this.eventSubscription = new Subscription();\n    if (typeof this.opts === 'number') {\n      this.opts = {\n        throttleDelay: this.opts,\n        passive: false\n      };\n    }\n    this.opts = this.opts || {\n      passive: false,\n      throttleDelay: defaultThrottleDelay\n    };\n    if (this.opts.throttleDelay === undefined || this.opts.throttleDelay === null) {\n      this.opts.throttleDelay = defaultThrottleDelay;\n    }\n    this.throttleDelay = this.opts.throttleDelay;\n    this.passive = !!this.opts.passive;\n  }\n  initialize(options) {\n    if (options?.platformId && isPlatformServer(options.platformId)) {\n      return;\n    }\n    const eventTarget = typeof this.target === 'function' ? this.target() : this.target;\n    const opts = this.passive ? {\n      passive: true\n    } : null;\n    const fromEvents = this.events.split(' ').map(eventName => fromEvent(eventTarget, eventName, opts));\n    this.eventSrc = merge(...fromEvents);\n    this.eventSrc = this.eventSrc.pipe(filter(innerArgs => !this.filterEvent(innerArgs)));\n    if (this.throttleDelay > 0) {\n      this.eventSrc = this.eventSrc.pipe(throttleTime(this.throttleDelay));\n    }\n    const handler = innerArgs => this.onInterrupt.emit(new InterruptArgs(this, innerArgs));\n    this.attachFn = () => this.eventSubscription = this.eventSrc.subscribe(handler);\n    this.detachFn = () => this.eventSubscription.unsubscribe();\n  }\n  /*\n   * Checks to see if the event should be filtered. Always returns false unless overriden.\n   * @param event - The original event object.\n   * @return True if the event should be filtered (don't cause an interrupt); otherwise, false.\n   */\n  filterEvent(event) {\n    return false;\n  }\n  /**\n   * Returns the current options being used.\n   * @return The current option values.\n   */\n  get options() {\n    return {\n      passive: this.passive,\n      throttleDelay: this.throttleDelay\n    };\n  }\n}\n\n/*\n * An interrupt source that uses events on the document element (html tag).\n */\nclass DocumentInterruptSource extends EventTargetInterruptSource {\n  constructor(events, options) {\n    super(() => document.documentElement, events, options);\n  }\n  /*\n   * Checks to see if the event should be filtered.\n   * @param event - The original event object.\n   * @return True if the event should be filtered (don't cause an interrupt); otherwise, false.\n   */\n  filterEvent(event) {\n    // some browser bad input hacks\n    if (event.type === 'mousemove' && (\n    // fix for Chrome destop notifications\n    event.originalEvent && event.originalEvent.movementX === 0 && event.originalEvent.movementY === 0 ||\n    // fix for webkit fake mousemove\n    event.movementX !== void 0 && !event.movementX || !event.movementY)) {\n      return true;\n    }\n    return false;\n  }\n}\n\n/*\n * An interrupt source on the Window object.\n */\nclass WindowInterruptSource extends EventTargetInterruptSource {\n  constructor(events, options) {\n    super(() => window, events, options);\n  }\n}\n\n/*\n * An interrupt source on the storage event of Window.\n */\nclass StorageInterruptSource extends WindowInterruptSource {\n  constructor(options = 500) {\n    super('storage', options);\n  }\n  /*\n   * Checks to see if the event should be filtered.\n   * @param event - The original event object.\n   * @return True if the event should be filtered (don't cause an interrupt); otherwise, false.\n   */\n  filterEvent(event) {\n    if (event.key && event.key.indexOf('ng2Idle.') >= 0 && event.key.indexOf('.expiry') >= 0) {\n      return false;\n    }\n    return true;\n  }\n}\n\n/*\n * Represents a simple in-memory store of expiry values.\n * @extends IdleExpiry\n */\nclass SimpleExpiry extends IdleExpiry {\n  constructor() {\n    super();\n    this.lastValue = null;\n  }\n  /*\n   * Gets or sets the last expiry date.\n   * @param value - The expiry value to set; omit to only return the value.\n   * @return The current expiry value.\n   */\n  last(value) {\n    if (value !== void 0) {\n      this.lastValue = value;\n    }\n    return this.lastValue;\n  }\n}\nclass NgIdleModule {\n  static forRoot() {\n    return {\n      ngModule: NgIdleModule,\n      providers: [LocalStorageExpiry, {\n        provide: IdleExpiry,\n        useExisting: LocalStorageExpiry\n      }, Idle]\n    };\n  }\n  static {\n    this.ɵfac = function NgIdleModule_Factory(t) {\n      return new (t || NgIdleModule)();\n    };\n  }\n  static {\n    this.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n      type: NgIdleModule\n    });\n  }\n  static {\n    this.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n      providers: [LocalStorage]\n    });\n  }\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NgIdleModule, [{\n    type: NgModule,\n    args: [{\n      providers: [LocalStorage]\n    }]\n  }], null, null);\n})();\nfunction createDefaultInterruptSources(options) {\n  return [new DocumentInterruptSource('mousemove keydown DOMMouseScroll mousewheel mousedown touchstart touchmove scroll', options), new StorageInterruptSource(options)];\n}\nconst DEFAULT_INTERRUPTSOURCES = createDefaultInterruptSources();\n\n/*\n * Public API Surface of core\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { AutoResume, DEFAULT_INTERRUPTSOURCES, DocumentInterruptSource, EventTargetInterruptSource, Idle, IdleExpiry, InterruptArgs, InterruptSource, KeepaliveSvc, LocalStorage, LocalStorageExpiry, NgIdleModule, SimpleExpiry, StorageInterruptSource, WindowInterruptSource, createDefaultInterruptSources };\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;AASA,IAAM,YAAN,MAAgB;AAAA,EACd,YAAY,QAAQ,SAAS;AAC3B,SAAK,SAAS;AACd,QAAI,OAAO,YAAY;AACrB,aAAO,WAAW,OAAO;AAAA,IAC3B;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA,EAKA,UAAU,IAAI;AACZ,SAAK,MAAM,KAAK,OAAO,YAAY,UAAU,EAAE;AAAA,EACjD;AAAA;AAAA;AAAA;AAAA,EAIA,cAAc;AACZ,SAAK,IAAI,YAAY;AACrB,SAAK,MAAM;AAAA,EACb;AAAA;AAAA;AAAA;AAAA,EAIA,SAAS;AACP,SAAK,OAAO,OAAO;AAAA,EACrB;AAAA;AAAA;AAAA;AAAA,EAIA,QAAQ;AACN,SAAK,OAAO,OAAO;AAAA,EACrB;AACF;AAKA,IAAM,aAAN,MAAiB;AAAA,EACf,cAAc;AACZ,SAAK,UAAU,oBAAI,KAAK;AACxB,SAAK,cAAc;AAAA,EACrB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,GAAG,OAAO;AACR,QAAI,UAAU,QAAQ;AACpB,UAAI,CAAC,OAAO;AACV,cAAM,IAAI,MAAM,uCAAuC;AAAA,MACzD;AACA,WAAK,UAAU;AAAA,IACjB;AACA,WAAO,KAAK;AAAA,EACd;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,OAAO,OAAO;AACZ,QAAI,UAAU,QAAQ;AACpB,WAAK,cAAc;AAAA,IACrB;AACA,WAAO,KAAK;AAAA,EACd;AAAA;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM;AAEJ,WAAO,oBAAI,KAAK;AAAA,EAClB;AAAA;AAAA;AAAA;AAAA;AAAA,EAKA,YAAY;AACV,UAAM,SAAS,KAAK,KAAK;AACzB,WAAO,UAAU,QAAQ,UAAU,KAAK,IAAI;AAAA,EAC9C;AACF;AAOA,IAAM,qBAAN,MAAyB;AAAA,EACvB,cAAc;AACZ,SAAK,aAAa,CAAC;AAAA,EACrB;AAAA;AAAA;AAAA;AAAA,EAIA,IAAI,SAAS;AACX,WAAO,OAAO,KAAK,KAAK,UAAU,EAAE;AAAA,EACtC;AAAA;AAAA;AAAA;AAAA,EAIA,QAAQ;AACN,SAAK,aAAa,CAAC;AAAA,EACrB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,QAAQ,KAAK;AACX,QAAI,OAAO,KAAK,WAAW,GAAG,MAAM,aAAa;AAC/C,aAAO,KAAK,WAAW,GAAG;AAAA,IAC5B;AACA,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,IAAI,OAAO;AACT,WAAO,OAAO,KAAK,KAAK,UAAU,EAAE,KAAK,KAAK;AAAA,EAChD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,WAAW,KAAK;AACd,SAAK,WAAW,GAAG,IAAI;AAAA,EACzB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,QAAQ,KAAK,OAAO;AAClB,SAAK,WAAW,GAAG,IAAI;AAAA,EACzB;AACF;AAKA,IAAM,gBAAN,MAAM,cAAa;AAAA,EACjB,cAAc;AACZ,SAAK,UAAU,KAAK,WAAW;AAAA,EACjC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,aAAa;AACX,QAAI;AACF,YAAM,UAAU;AAChB,cAAQ,QAAQ,kBAAkB,EAAE;AACpC,cAAQ,WAAW,gBAAgB;AACnC,aAAO;AAAA,IACT,SAAS,KAAK;AACZ,aAAO,IAAI,mBAAmB;AAAA,IAChC;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,QAAQ,KAAK;AACX,WAAO,KAAK,QAAQ,QAAQ,aAAa,GAAG;AAAA,EAC9C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,WAAW,KAAK;AACd,SAAK,QAAQ,WAAW,aAAa,GAAG;AAAA,EAC1C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,QAAQ,KAAK,MAAM;AACjB,SAAK,QAAQ,QAAQ,aAAa,KAAK,IAAI;AAAA,EAC7C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,WAAW;AACT,WAAO,KAAK;AAAA,EACd;AAYF;AAVI,cAAK,OAAO,SAAS,qBAAqB,GAAG;AAC3C,SAAO,KAAK,KAAK,eAAc;AACjC;AAGA,cAAK,QAA0B,mBAAmB;AAAA,EAChD,OAAO;AAAA,EACP,SAAS,cAAa;AACxB,CAAC;AAhEL,IAAM,eAAN;AAAA,CAmEC,MAAM;AACL,GAAC,OAAO,cAAc,eAAe,cAAiB,iBAAkB,cAAc,CAAC;AAAA,IACrF,MAAM;AAAA,EACR,CAAC,GAAG,WAAY;AACd,WAAO,CAAC;AAAA,EACV,GAAG,IAAI;AACT,GAAG;AAMH,IAAM,sBAAN,MAAM,4BAA2B,WAAW;AAAA,EAC1C,YAAYA,eAAc;AACxB,UAAM;AACN,SAAK,eAAeA;AACpB,SAAK,WAAW;AAAA,EAClB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,KAAK,OAAO;AACV,QAAI,UAAU,QAAQ;AACpB,WAAK,UAAU,KAAK;AAAA,IACtB;AACA,WAAO,KAAK,UAAU;AAAA,EACxB;AAAA,EACA,OAAO,OAAO;AACZ,QAAI,UAAU,QAAQ;AACpB,WAAK,UAAU,KAAK;AAAA,IACtB;AACA,WAAO,KAAK,UAAU;AAAA,EACxB;AAAA;AAAA;AAAA;AAAA;AAAA,EAKA,cAAc;AACZ,WAAO,KAAK;AAAA,EACd;AAAA;AAAA;AAAA;AAAA;AAAA,EAKA,YAAY,KAAK;AACf,QAAI,KAAK;AACP,WAAK,WAAW;AAAA,IAClB;AAAA,EACF;AAAA,EACA,YAAY;AACV,UAAM,SAAS,KAAK,aAAa,QAAQ,KAAK,WAAW,SAAS;AAClE,QAAI,QAAQ;AACV,aAAO,IAAI,KAAK,SAAS,QAAQ,EAAE,CAAC;AAAA,IACtC,OAAO;AACL,aAAO;AAAA,IACT;AAAA,EACF;AAAA,EACA,UAAU,OAAO;AACf,QAAI,OAAO;AACT,WAAK,aAAa,QAAQ,KAAK,WAAW,WAAW,MAAM,QAAQ,EAAE,SAAS,CAAC;AAAA,IACjF,OAAO;AACL,WAAK,aAAa,WAAW,KAAK,WAAW,SAAS;AAAA,IACxD;AAAA,EACF;AAAA,EACA,YAAY;AACV,UAAM,SAAS,KAAK,aAAa,QAAQ,KAAK,WAAW,SAAS;AAClE,QAAI,QAAQ;AACV,aAAO,WAAW;AAAA,IACpB,OAAO;AACL,aAAO;AAAA,IACT;AAAA,EACF;AAAA,EACA,UAAU,OAAO;AACf,QAAI,OAAO;AACT,WAAK,aAAa,QAAQ,KAAK,WAAW,WAAW,MAAM,SAAS,CAAC;AAAA,IACvE,OAAO;AACL,WAAK,aAAa,QAAQ,KAAK,WAAW,WAAW,OAAO;AAAA,IAC9D;AAAA,EACF;AAYF;AAVI,oBAAK,OAAO,SAAS,2BAA2B,GAAG;AACjD,SAAO,KAAK,KAAK,qBAAuB,SAAS,YAAY,CAAC;AAChE;AAGA,oBAAK,QAA0B,mBAAmB;AAAA,EAChD,OAAO;AAAA,EACP,SAAS,oBAAmB;AAC9B,CAAC;AA/EL,IAAM,qBAAN;AAAA,CAkFC,MAAM;AACL,GAAC,OAAO,cAAc,eAAe,cAAiB,iBAAkB,oBAAoB,CAAC;AAAA,IAC3F,MAAM;AAAA,EACR,CAAC,GAAG,WAAY;AACd,WAAO,CAAC;AAAA,MACN,MAAM;AAAA,IACR,CAAC;AAAA,EACH,GAAG,IAAI;AACT,GAAG;AACH,IAAM,eAAN,MAAmB;AAAC;AAKpB,IAAI;AAAA,CACH,SAAUC,aAAY;AAIrB,EAAAA,YAAWA,YAAW,UAAU,IAAI,CAAC,IAAI;AAIzC,EAAAA,YAAWA,YAAW,MAAM,IAAI,CAAC,IAAI;AAIrC,EAAAA,YAAWA,YAAW,SAAS,IAAI,CAAC,IAAI;AAC1C,GAAG,eAAe,aAAa,CAAC,EAAE;AAIlC,IAAM,QAAN,MAAM,MAAK;AAAA,EACT,YAAY,QAAQ,MAAM,cAAc,YAAY;AAClD,SAAK,SAAS;AACd,SAAK,OAAO;AACZ,SAAK,aAAa;AAClB,SAAK,OAAO,KAAK;AACjB,SAAK,aAAa;AAClB,SAAK,aAAa,WAAW;AAC7B,SAAK,aAAa,IAAI,MAAM;AAC5B,SAAK,UAAU;AACf,SAAK,mBAAmB;AACxB,SAAK,cAAc,IAAI,aAAa;AACpC,SAAK,YAAY,IAAI,aAAa;AAClC,SAAK,mBAAmB,IAAI,aAAa;AACzC,SAAK,YAAY,IAAI,aAAa;AAClC,SAAK,cAAc,IAAI,aAAa;AACpC,QAAI,cAAc;AAChB,WAAK,eAAe;AACpB,WAAK,mBAAmB;AAAA,IAC1B;AACA,SAAK,UAAU,KAAK;AAAA,EACtB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,YAAY,KAAK;AACf,QAAI,KAAK,kBAAkB,oBAAoB;AAC7C,WAAK,OAAO,YAAY,GAAG;AAAA,IAC7B,OAAO;AACL,YAAM,IAAI,MAAM,6EAA6E;AAAA,IAC/F;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA,EAKA,sBAAsB;AACpB,WAAO,KAAK;AAAA,EACd;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,oBAAoB,OAAO;AACzB,QAAI,CAAC,KAAK,cAAc;AACtB,YAAM,IAAI,MAAM,gFAAgF;AAAA,IAClG;AACA,WAAO,KAAK,mBAAmB;AAAA,EACjC;AAAA;AAAA;AAAA;AAAA;AAAA,EAKA,aAAa;AACX,WAAO,KAAK;AAAA,EACd;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,WAAW,SAAS;AAClB,QAAI,YAAY,OAAO;AACrB,WAAK,aAAa;AAAA,IACpB,WAAW,OAAO,YAAY,YAAY,WAAW,GAAG;AACtD,WAAK,aAAa;AAAA,IACpB,OAAO;AACL,YAAM,IAAI,MAAM,qDAAqD;AAAA,IACvE;AACA,WAAO,KAAK;AAAA,EACd;AAAA;AAAA;AAAA;AAAA;AAAA,EAKA,UAAU;AACR,WAAO,KAAK;AAAA,EACd;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,QAAQ,SAAS;AACf,QAAI,WAAW,GAAG;AAChB,YAAM,IAAI,MAAM,gCAAgC;AAAA,IAClD;AACA,WAAO,KAAK,OAAO;AAAA,EACrB;AAAA;AAAA;AAAA;AAAA;AAAA,EAKA,gBAAgB;AACd,WAAO,KAAK;AAAA,EACd;AAAA,EACA,cAAc,OAAO;AACnB,WAAO,KAAK,aAAa;AAAA,EAC3B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,cAAc,SAAS;AACrB,SAAK,gBAAgB;AACrB,UAAM,OAAO;AACb,eAAW,UAAU,SAAS;AAC5B,YAAM,UAAU;AAAA,QACd,YAAY,KAAK;AAAA,MACnB;AACA,YAAM,MAAM,IAAI,UAAU,QAAQ,OAAO;AACzC,UAAI,UAAU,UAAQ;AACpB,aAAK,UAAU,KAAK,OAAO,KAAK,SAAS;AAAA,MAC3C,CAAC;AACD,WAAK,WAAW,KAAK,GAAG;AAAA,IAC1B;AACA,WAAO,KAAK;AAAA,EACd;AAAA;AAAA;AAAA;AAAA;AAAA,EAKA,gBAAgB;AACd,WAAO,KAAK;AAAA,EACd;AAAA;AAAA;AAAA;AAAA,EAIA,kBAAkB;AAChB,eAAW,OAAO,KAAK,YAAY;AACjC,UAAI,MAAM;AACV,UAAI,YAAY;AAAA,IAClB;AACA,SAAK,WAAW,SAAS;AAAA,EAC3B;AAAA;AAAA;AAAA;AAAA;AAAA,EAKA,YAAY;AACV,WAAO,KAAK;AAAA,EACd;AAAA;AAAA;AAAA;AAAA;AAAA,EAKA,WAAW;AACT,WAAO,KAAK;AAAA,EACd;AAAA;AAAA;AAAA;AAAA,EAIA,MAAM,YAAY;AAChB,SAAK,kBAAkB,YAAY;AACnC,SAAK,kBAAkB,eAAe;AACtC,UAAM,UAAU,CAAC,KAAK,aAAa,IAAI,KAAK;AAC5C,QAAI,CAAC,YAAY;AACf,YAAM,QAAQ,IAAI,KAAK,KAAK,OAAO,IAAI,EAAE,QAAQ,KAAK,KAAK,OAAO,WAAW,GAAI;AACjF,WAAK,OAAO,KAAK,KAAK;AAAA,IACxB;AACA,QAAI,KAAK,QAAQ;AACf,WAAK,YAAY;AAAA,IACnB;AACA,QAAI,CAAC,KAAK,SAAS;AACjB,WAAK,eAAe;AACpB,WAAK,iBAAiB,IAAI;AAAA,IAC5B;AACA,SAAK,UAAU;AACf,UAAM,UAAU,MAAM;AACpB,WAAK,KAAK,IAAI,MAAM;AAClB,cAAM,OAAO,KAAK,cAAc,OAAO;AACvC,YAAI,OAAO,GAAG;AACZ,eAAK,kBAAkB,YAAY;AACnC,eAAK,6BAA6B,SAAS,GAAI;AAAA,QACjD,OAAO;AACL,eAAK,YAAY;AAAA,QACnB;AAAA,MACF,CAAC;AAAA,IACH;AACA,SAAK,6BAA6B,SAAS,GAAI;AAAA,EACjD;AAAA;AAAA;AAAA;AAAA,EAIA,6BAA6B,SAAS,WAAW;AAC/C,SAAK,KAAK,kBAAkB,MAAM;AAChC,WAAK,aAAa,YAAY,SAAS,SAAS;AAAA,IAClD,CAAC;AAAA,EACH;AAAA;AAAA;AAAA;AAAA,EAIA,OAAO;AACL,SAAK,cAAc;AACnB,SAAK,iBAAiB,KAAK;AAC3B,SAAK,kBAAkB,YAAY;AACnC,SAAK,kBAAkB,eAAe;AACtC,SAAK,UAAU,KAAK;AACpB,SAAK,UAAU;AACf,SAAK,OAAO,KAAK,IAAI;AAAA,EACvB;AAAA;AAAA;AAAA;AAAA,EAIA,UAAU;AACR,SAAK,cAAc;AACnB,SAAK,iBAAiB,KAAK;AAC3B,SAAK,kBAAkB,YAAY;AACnC,SAAK,kBAAkB,eAAe;AACtC,SAAK,UAAU,IAAI;AACnB,SAAK,UAAU;AACf,SAAK,YAAY;AACjB,SAAK,UAAU,KAAK,IAAI;AAAA,EAC1B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,UAAU,OAAO,WAAW;AAC1B,QAAI,CAAC,KAAK,SAAS;AACjB;AAAA,IACF;AACA,QAAI,KAAK,cAAc,KAAK,OAAO,UAAU,GAAG;AAC9C,WAAK,QAAQ;AACb;AAAA,IACF;AACA,SAAK,YAAY,KAAK,SAAS;AAC/B,QAAI,UAAU,QAAQ,KAAK,eAAe,WAAW,QAAQ,KAAK,eAAe,WAAW,WAAW,CAAC,KAAK,OAAO,OAAO,GAAG;AAC5H,WAAK,MAAM,KAAK;AAAA,IAClB;AAAA,EACF;AAAA,EACA,UAAU,OAAO;AACf,SAAK,SAAS;AACd,SAAK,OAAO,OAAO,KAAK;AAAA,EAC1B;AAAA,EACA,cAAc;AACZ,SAAK,UAAU,CAAC,KAAK,MAAM;AAC3B,QAAI,KAAK,QAAQ;AACf,WAAK,YAAY,KAAK,IAAI;AAC1B,WAAK,cAAc;AACnB,UAAI,KAAK,aAAa,GAAG;AACvB,aAAK,YAAY,KAAK;AACtB,aAAK,YAAY;AACjB,aAAK,8BAA8B,MAAM;AACvC,eAAK,kBAAkB;AAAA,QACzB,GAAG,GAAI;AAAA,MACT;AAAA,IACF,OAAO;AACL,WAAK,iBAAiB,IAAI;AAC1B,WAAK,UAAU,KAAK,IAAI;AACxB,WAAK,eAAe;AAAA,IACtB;AACA,SAAK,kBAAkB,YAAY;AAAA,EACrC;AAAA,EACA,8BAA8B,YAAY,WAAW;AACnD,SAAK,KAAK,kBAAkB,MAAM;AAChC,WAAK,gBAAgB,YAAY,MAAM;AACrC,mBAAW;AAAA,MACb,GAAG,SAAS;AAAA,IACd,CAAC;AAAA,EACH;AAAA,EACA,iBAAiB,QAAQ;AACvB,eAAW,aAAa,KAAK,YAAY;AACvC,UAAI,QAAQ;AACV,kBAAU,OAAO;AAAA,MACnB,OAAO;AACL,kBAAU,MAAM;AAAA,MAClB;AAAA,IACF;AAAA,EACF;AAAA,EACA,cAAc,SAAS;AACrB,UAAM,MAAM,KAAK,OAAO,IAAI;AAC5B,UAAM,OAAO,KAAK,OAAO,KAAK,KAAK;AACnC,WAAO,KAAK,QAAQ,IAAI,IAAI,QAAQ,IAAI,UAAU;AAAA,EACpD;AAAA,EACA,oBAAoB;AAClB,SAAK,KAAK,IAAI,MAAM;AAClB,WAAK,YAAY;AAAA,IACnB,CAAC;AAAA,EACH;AAAA,EACA,cAAc;AACZ,UAAM,OAAO,KAAK,cAAc,KAAK,UAAU;AAC/C,QAAI,OAAO,GAAG;AACZ,WAAK,kBAAkB,eAAe;AACtC,WAAK,UAAU,IAAI;AACnB;AAAA,IACF;AACA,QAAI,CAAC,KAAK,QAAQ;AAChB;AAAA,IACF;AACA,QAAI,KAAK,aAAa,GAAG;AACvB,WAAK,QAAQ;AACb;AAAA,IACF;AACA,SAAK,iBAAiB,KAAK,KAAK,SAAS;AACzC,UAAM,eAAe,KAAK,aAAa,KAAK,MAAO;AACnD,SAAK,YAAY,KAAK,MAAM,cAAc,GAAI;AAAA,EAChD;AAAA,EACA,kBAAkB,YAAY;AAC5B,UAAM,SAAS,KAAK,UAAU;AAC9B,QAAI,WAAW,QAAQ,OAAO,WAAW,aAAa;AACpD,oBAAc,KAAK,UAAU,CAAC;AAC9B,WAAK,UAAU,IAAI;AAAA,IACrB;AAAA,EACF;AAAA,EACA,iBAAiB;AACf,QAAI,CAAC,KAAK,gBAAgB,CAAC,KAAK,kBAAkB;AAChD;AAAA,IACF;AACA,QAAI,KAAK,SAAS;AAChB,WAAK,aAAa,KAAK;AAAA,IACzB;AACA,SAAK,aAAa,MAAM;AAAA,EAC1B;AAAA,EACA,gBAAgB;AACd,QAAI,CAAC,KAAK,gBAAgB,CAAC,KAAK,kBAAkB;AAChD;AAAA,IACF;AACA,SAAK,aAAa,KAAK;AAAA,EACzB;AAAA;AAAA;AAAA;AAAA,EAIA,cAAc;AACZ,SAAK,KAAK;AACV,SAAK,gBAAgB;AAAA,EACvB;AAYF;AAVI,MAAK,OAAO,SAAS,aAAa,GAAG;AACnC,SAAO,KAAK,KAAK,OAAS,SAAS,UAAU,GAAM,SAAY,MAAM,GAAM,SAAS,cAAc,CAAC,GAAM,SAAS,aAAa,CAAC,CAAC;AACnI;AAGA,MAAK,QAA0B,mBAAmB;AAAA,EAChD,OAAO;AAAA,EACP,SAAS,MAAK;AAChB,CAAC;AArVL,IAAM,OAAN;AAAA,CAwVC,MAAM;AACL,GAAC,OAAO,cAAc,eAAe,cAAiB,iBAAkB,MAAM,CAAC;AAAA,IAC7E,MAAM;AAAA,EACR,CAAC,GAAG,WAAY;AACd,WAAO,CAAC;AAAA,MACN,MAAM;AAAA,IACR,GAAG;AAAA,MACD,MAAS;AAAA,IACX,GAAG;AAAA,MACD,MAAM;AAAA,MACN,YAAY,CAAC;AAAA,QACX,MAAM;AAAA,MACR,CAAC;AAAA,IACH,GAAG;AAAA,MACD,MAAM;AAAA,MACN,YAAY,CAAC;AAAA,QACX,MAAM;AAAA,MACR,GAAG;AAAA,QACD,MAAM;AAAA,QACN,MAAM,CAAC,WAAW;AAAA,MACpB,CAAC;AAAA,IACH,CAAC;AAAA,EACH,GAAG,IAAI;AACT,GAAG;AAKH,IAAM,gBAAN,MAAoB;AAAA,EAClB,YAAY,QAAQ,WAAW,QAAQ,OAAO;AAC5C,SAAK,SAAS;AACd,SAAK,YAAY;AACjB,SAAK,QAAQ;AAAA,EACf;AACF;AAKA,IAAM,kBAAN,MAAsB;AAAA,EACpB,YAAY,UAAU,UAAU;AAC9B,SAAK,WAAW;AAChB,SAAK,WAAW;AAChB,SAAK,aAAa;AAClB,SAAK,cAAc,IAAI,aAAa;AAAA,EACtC;AAAA;AAAA;AAAA;AAAA,EAIA,SAAS;AAIP,QAAI,KAAK,QAAQ,IAAI,eAAe,MAAM,MAAM;AAC9C,WAAK,QAAQ,OAAO,IAAI,MAAM,KAAK,OAAO,CAAC;AAC3C;AAAA,IACF;AACA,QAAI,CAAC,KAAK,cAAc,KAAK,UAAU;AACrC,WAAK,SAAS,IAAI;AAAA,IACpB;AACA,SAAK,aAAa;AAAA,EACpB;AAAA;AAAA;AAAA;AAAA,EAIA,SAAS;AACP,QAAI,KAAK,cAAc,KAAK,UAAU;AACpC,WAAK,SAAS,IAAI;AAAA,IACpB;AACA,SAAK,aAAa;AAAA,EACpB;AACF;AACA,IAAM,uBAAuB;AAI7B,IAAM,6BAAN,cAAyC,gBAAgB;AAAA,EACvD,YAAY,QAAQ,QAAQ,MAAM;AAChC,UAAM,MAAM,IAAI;AAChB,SAAK,SAAS;AACd,SAAK,SAAS;AACd,SAAK,OAAO;AACZ,SAAK,oBAAoB,IAAI,aAAa;AAC1C,QAAI,OAAO,KAAK,SAAS,UAAU;AACjC,WAAK,OAAO;AAAA,QACV,eAAe,KAAK;AAAA,QACpB,SAAS;AAAA,MACX;AAAA,IACF;AACA,SAAK,OAAO,KAAK,QAAQ;AAAA,MACvB,SAAS;AAAA,MACT,eAAe;AAAA,IACjB;AACA,QAAI,KAAK,KAAK,kBAAkB,UAAa,KAAK,KAAK,kBAAkB,MAAM;AAC7E,WAAK,KAAK,gBAAgB;AAAA,IAC5B;AACA,SAAK,gBAAgB,KAAK,KAAK;AAC/B,SAAK,UAAU,CAAC,CAAC,KAAK,KAAK;AAAA,EAC7B;AAAA,EACA,WAAW,SAAS;AAClB,QAAI,SAAS,cAAc,iBAAiB,QAAQ,UAAU,GAAG;AAC/D;AAAA,IACF;AACA,UAAM,cAAc,OAAO,KAAK,WAAW,aAAa,KAAK,OAAO,IAAI,KAAK;AAC7E,UAAM,OAAO,KAAK,UAAU;AAAA,MAC1B,SAAS;AAAA,IACX,IAAI;AACJ,UAAM,aAAa,KAAK,OAAO,MAAM,GAAG,EAAE,IAAI,eAAa,UAAU,aAAa,WAAW,IAAI,CAAC;AAClG,SAAK,WAAW,MAAM,GAAG,UAAU;AACnC,SAAK,WAAW,KAAK,SAAS,KAAK,OAAO,eAAa,CAAC,KAAK,YAAY,SAAS,CAAC,CAAC;AACpF,QAAI,KAAK,gBAAgB,GAAG;AAC1B,WAAK,WAAW,KAAK,SAAS,KAAK,aAAa,KAAK,aAAa,CAAC;AAAA,IACrE;AACA,UAAM,UAAU,eAAa,KAAK,YAAY,KAAK,IAAI,cAAc,MAAM,SAAS,CAAC;AACrF,SAAK,WAAW,MAAM,KAAK,oBAAoB,KAAK,SAAS,UAAU,OAAO;AAC9E,SAAK,WAAW,MAAM,KAAK,kBAAkB,YAAY;AAAA,EAC3D;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,YAAY,OAAO;AACjB,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA,EAKA,IAAI,UAAU;AACZ,WAAO;AAAA,MACL,SAAS,KAAK;AAAA,MACd,eAAe,KAAK;AAAA,IACtB;AAAA,EACF;AACF;AAKA,IAAM,0BAAN,cAAsC,2BAA2B;AAAA,EAC/D,YAAY,QAAQ,SAAS;AAC3B,UAAM,MAAM,SAAS,iBAAiB,QAAQ,OAAO;AAAA,EACvD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,YAAY,OAAO;AAEjB,QAAI,MAAM,SAAS;AAAA,KAEnB,MAAM,iBAAiB,MAAM,cAAc,cAAc,KAAK,MAAM,cAAc,cAAc;AAAA,IAEhG,MAAM,cAAc,UAAU,CAAC,MAAM,aAAa,CAAC,MAAM,YAAY;AACnE,aAAO;AAAA,IACT;AACA,WAAO;AAAA,EACT;AACF;AAKA,IAAM,wBAAN,cAAoC,2BAA2B;AAAA,EAC7D,YAAY,QAAQ,SAAS;AAC3B,UAAM,MAAM,QAAQ,QAAQ,OAAO;AAAA,EACrC;AACF;AAKA,IAAM,yBAAN,cAAqC,sBAAsB;AAAA,EACzD,YAAY,UAAU,KAAK;AACzB,UAAM,WAAW,OAAO;AAAA,EAC1B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,YAAY,OAAO;AACjB,QAAI,MAAM,OAAO,MAAM,IAAI,QAAQ,UAAU,KAAK,KAAK,MAAM,IAAI,QAAQ,SAAS,KAAK,GAAG;AACxF,aAAO;AAAA,IACT;AACA,WAAO;AAAA,EACT;AACF;AAMA,IAAM,eAAN,cAA2B,WAAW;AAAA,EACpC,cAAc;AACZ,UAAM;AACN,SAAK,YAAY;AAAA,EACnB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,KAAK,OAAO;AACV,QAAI,UAAU,QAAQ;AACpB,WAAK,YAAY;AAAA,IACnB;AACA,WAAO,KAAK;AAAA,EACd;AACF;AACA,IAAM,gBAAN,MAAM,cAAa;AAAA,EACjB,OAAO,UAAU;AACf,WAAO;AAAA,MACL,UAAU;AAAA,MACV,WAAW,CAAC,oBAAoB;AAAA,QAC9B,SAAS;AAAA,QACT,aAAa;AAAA,MACf,GAAG,IAAI;AAAA,IACT;AAAA,EACF;AAgBF;AAdI,cAAK,OAAO,SAAS,qBAAqB,GAAG;AAC3C,SAAO,KAAK,KAAK,eAAc;AACjC;AAGA,cAAK,OAAyB,iBAAiB;AAAA,EAC7C,MAAM;AACR,CAAC;AAGD,cAAK,OAAyB,iBAAiB;AAAA,EAC7C,WAAW,CAAC,YAAY;AAC1B,CAAC;AAvBL,IAAM,eAAN;AAAA,CA0BC,MAAM;AACL,GAAC,OAAO,cAAc,eAAe,cAAiB,iBAAkB,cAAc,CAAC;AAAA,IACrF,MAAM;AAAA,IACN,MAAM,CAAC;AAAA,MACL,WAAW,CAAC,YAAY;AAAA,IAC1B,CAAC;AAAA,EACH,CAAC,GAAG,MAAM,IAAI;AAChB,GAAG;AACH,SAAS,8BAA8B,SAAS;AAC9C,SAAO,CAAC,IAAI,wBAAwB,qFAAqF,OAAO,GAAG,IAAI,uBAAuB,OAAO,CAAC;AACxK;AACA,IAAM,2BAA2B,8BAA8B;",
  "names": ["localStorage", "AutoResume"]
}
